(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.headlessui = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  var useIsoMorphicEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

  // didn't take care of the Suspense case. To fix this we used the approach the @reach-ui/auto-id
  // uses.
  //
  // Credits: https://github.com/reach/reach-ui/blob/develop/packages/auto-id/src/index.tsx

  var state = {
    serverHandoffComplete: false
  };
  var id = 0;

  function generateId() {
    return ++id;
  }

  function useId() {
    var _React$useState = React.useState(state.serverHandoffComplete ? generateId : null),
        id = _React$useState[0],
        setId = _React$useState[1];

    useIsoMorphicEffect(function () {
      if (id === null) setId(generateId()); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    React.useEffect(function () {
      if (state.serverHandoffComplete === false) state.serverHandoffComplete = true;
    }, []);
    return id != null ? '' + id : undefined;
  }

  function useIsInitialRender() {
    var initial = React.useRef(true);
    React.useEffect(function () {
      initial.current = false;
    }, []);
    return initial.current;
  }

  function useIsMounted() {
    var mounted = React.useRef(true);
    React.useEffect(function () {
      return function () {
        mounted.current = false;
      };
    }, []);
    return mounted;
  }

  function match(value, lookup) {
    if (value in lookup) {
      var returnValue = lookup[value];

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      return typeof returnValue === 'function' ? returnValue.apply(void 0, args) : returnValue;
    }

    var error = new Error("Tried to handle \"" + value + "\" but there is no handler defined. Only defined handlers are: " + Object.keys(lookup).map(function (key) {
      return "\"" + key + "\"";
    }).join(', ') + ".");

    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, match);
    }

    throw error;
  }

  function once(cb) {
    var state = {
      called: false
    };
    return function () {
      if (state.called) {
        return;
      }

      state.called = true;
      return cb.apply(void 0, arguments);
    };
  }

  function disposables() {
    var disposables = [];
    var api = {
      requestAnimationFrame: function (_requestAnimationFrame) {
        function requestAnimationFrame() {
          return _requestAnimationFrame.apply(this, arguments);
        }

        requestAnimationFrame.toString = function () {
          return _requestAnimationFrame.toString();
        };

        return requestAnimationFrame;
      }(function () {
        var raf = requestAnimationFrame.apply(void 0, arguments);
        api.add(function () {
          return cancelAnimationFrame(raf);
        });
      }),
      nextFrame: function nextFrame() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        api.requestAnimationFrame(function () {
          api.requestAnimationFrame.apply(api, args);
        });
      },
      setTimeout: function (_setTimeout) {
        function setTimeout() {
          return _setTimeout.apply(this, arguments);
        }

        setTimeout.toString = function () {
          return _setTimeout.toString();
        };

        return setTimeout;
      }(function () {
        var timer = setTimeout.apply(void 0, arguments);
        api.add(function () {
          return clearTimeout(timer);
        });
      }),
      add: function add(cb) {
        disposables.push(cb);
      },
      dispose: function dispose() {
        disposables.splice(0).forEach(function (dispose) {
          return dispose();
        });
      }
    };
    return api;
  }

  function addClasses(node) {
    var _node$classList;

    for (var _len = arguments.length, classes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      classes[_key - 1] = arguments[_key];
    }

    node && classes.length > 0 && (_node$classList = node.classList).add.apply(_node$classList, classes);
  }

  function removeClasses(node) {
    var _node$classList2;

    for (var _len2 = arguments.length, classes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      classes[_key2 - 1] = arguments[_key2];
    }

    node && classes.length > 0 && (_node$classList2 = node.classList).remove.apply(_node$classList2, classes);
  }

  var Reason;

  (function (Reason) {
    Reason["Finished"] = "finished";
    Reason["Cancelled"] = "cancelled";
  })(Reason || (Reason = {}));

  function waitForTransition(node, done) {
    var d = disposables();
    if (!node) return d.dispose; // Safari returns a comma separated list of values, so let's sort them and take the highest value.

    var _getComputedStyle = getComputedStyle(node),
        transitionDuration = _getComputedStyle.transitionDuration,
        transitionDelay = _getComputedStyle.transitionDelay;

    var _map = [transitionDuration, transitionDelay].map(function (value) {
      var _value$split$filter$m = value.split(',') // Remove falseys we can't work with
      .filter(Boolean) // Values are returned as `0.3s` or `75ms`
      .map(function (v) {
        return v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000;
      }).sort(function (a, z) {
        return z - a;
      }),
          _value$split$filter$m2 = _value$split$filter$m[0],
          resolvedValue = _value$split$filter$m2 === void 0 ? 0 : _value$split$filter$m2;

      return resolvedValue;
    }),
        durationMs = _map[0],
        delaysMs = _map[1]; // Waiting for the transition to end. We could use the `transitionend` event, however when no
    // actual transition/duration is defined then the `transitionend` event is not fired.
    //
    // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the
    // full 100% speed instead of the 25% or 10%.


    if (durationMs !== 0) {
      d.setTimeout(function () {
        done(Reason.Finished);
      }, durationMs + delaysMs);
    } else {
      // No transition is happening, so we should cleanup already. Otherwise we have to wait until we
      // get disposed.
      done(Reason.Finished);
    } // If we get disposed before the timeout runs we should cleanup anyway


    d.add(function () {
      return done(Reason.Cancelled);
    });
    return d.dispose;
  }

  function transition(node, base, from, to, done) {
    var d = disposables();

    var _done = done !== undefined ? once(done) : function () {};

    addClasses.apply(void 0, [node].concat(base, from));
    d.nextFrame(function () {
      removeClasses.apply(void 0, [node].concat(from));
      addClasses.apply(void 0, [node].concat(to));
      d.add(waitForTransition(node, function (reason) {
        removeClasses.apply(void 0, [node].concat(to, base));
        return _done(reason);
      }));
    }); // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,
    // the node itself will be nullified and will be a no-op. In case of a full transition the classes
    // are already removed which is also a no-op. However if you go from enter -> leave mid-transition
    // then we have some leftovers that should be cleaned.

    d.add(function () {
      return removeClasses.apply(void 0, [node].concat(base, from, to));
    }); // When we get disposed early, than we should also call the done method but switch the reason.

    d.add(function () {
      return _done(Reason.Cancelled);
    });
    return d.dispose;
  }

  function useSplitClasses(classes) {
    if (classes === void 0) {
      classes = '';
    }

    return React.useMemo(function () {
      return classes.split(' ').filter(function (className) {
        return className.trim().length > 1;
      });
    }, [classes]);
  }

  var TransitionContext = /*#__PURE__*/React.createContext(null);
  var TreeStates;

  (function (TreeStates) {
    TreeStates["Visible"] = "visible";
    TreeStates["Hidden"] = "hidden";
  })(TreeStates || (TreeStates = {}));

  function useTransitionContext() {
    var context = React.useContext(TransitionContext);

    if (context === null) {
      throw new Error('A <Transition.Child /> is used but it is missing a parent <Transition />.');
    }

    return context;
  }

  function useParentNesting() {
    var context = React.useContext(NestingContext);

    if (context === null) {
      throw new Error('A <Transition.Child /> is used but it is missing a parent <Transition />.');
    }

    return context;
  }

  var NestingContext = /*#__PURE__*/React.createContext(null);

  function useNesting(done) {
    var doneRef = React.useRef(done);
    var transitionableChildren = React.useRef([]);
    var mounted = useIsMounted();
    React.useEffect(function () {
      doneRef.current = done;
    }, [done]);
    var unregister = React.useCallback(function (childId) {
      var idx = transitionableChildren.current.indexOf(childId);
      if (idx === -1) return;
      transitionableChildren.current.splice(idx, 1);

      if (transitionableChildren.current.length <= 0 && mounted.current) {
        var _doneRef$current;

        (_doneRef$current = doneRef.current) === null || _doneRef$current === void 0 ? void 0 : _doneRef$current.call(doneRef);
      }
    }, [doneRef, mounted, transitionableChildren]);
    var register = React.useCallback(function (childId) {
      transitionableChildren.current.push(childId);
      return function () {
        return unregister(childId);
      };
    }, [transitionableChildren, unregister]);
    return React.useMemo(function () {
      return {
        children: transitionableChildren,
        register: register,
        unregister: unregister
      };
    }, [register, unregister, transitionableChildren]);
  }

  function TransitionChild(props) {
    var children = props.children,
        enter = props.enter,
        enterFrom = props.enterFrom,
        enterTo = props.enterTo,
        leave = props.leave,
        leaveFrom = props.leaveFrom,
        leaveTo = props.leaveTo,
        rest = _objectWithoutPropertiesLoose(props, ["children", "enter", "enterFrom", "enterTo", "leave", "leaveFrom", "leaveTo"]);

    var container = React.useRef(null);

    var _React$useState = React.useState(TreeStates.Visible),
        state = _React$useState[0],
        setState = _React$useState[1];

    var _useTransitionContext = useTransitionContext(),
        show = _useTransitionContext.show,
        appear = _useTransitionContext.appear;

    var _useParentNesting = useParentNesting(),
        register = _useParentNesting.register,
        unregister = _useParentNesting.unregister;

    var initial = useIsInitialRender();
    var id = useId();
    var isTransitioning = React.useRef(false);
    var nesting = useNesting(function () {
      // When all children have been unmounted we can only hide ourselves if and only if we are not
      // transitioning ourserlves. Otherwise we would unmount before the transitions are finished.
      if (!isTransitioning.current) {
        setState(TreeStates.Hidden);
        unregister(id);
      }
    });
    useIsoMorphicEffect(function () {
      if (!id) return;
      return register(id);
    }, [register, id]);
    var enterClasses = useSplitClasses(enter);
    var enterFromClasses = useSplitClasses(enterFrom);
    var enterToClasses = useSplitClasses(enterTo);
    var leaveClasses = useSplitClasses(leave);
    var leaveFromClasses = useSplitClasses(leaveFrom);
    var leaveToClasses = useSplitClasses(leaveTo);
    React.useEffect(function () {
      if (state === TreeStates.Visible && container.current === null) {
        throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?');
      }
    }, [container, state]); // Skipping initial transition

    var skip = initial && !appear;
    useIsoMorphicEffect(function () {
      var node = container.current;
      if (!node) return;
      if (skip) return;
      isTransitioning.current = true;
      return show ? transition(node, enterClasses, enterFromClasses, enterToClasses, function () {
        isTransitioning.current = false;
      }) : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, function (reason) {
        isTransitioning.current = false;
        if (reason !== Reason.Finished) return; // When we don't have children anymore we can safely unregister from the parent and hide
        // ourselves.

        if (nesting.children.current.length <= 0) {
          setState(TreeStates.Hidden);
          unregister(id);
        }
      });
    }, [id, isTransitioning, unregister, nesting, container, skip, show, enterClasses, enterFromClasses, enterToClasses, leaveClasses, leaveFromClasses, leaveToClasses]); // Unmount the whole tree

    if (state === TreeStates.Hidden) return null;

    if (typeof children === 'function') {
      return React.createElement(NestingContext.Provider, {
        value: nesting
      }, children(container));
    }

    var _rest$as = rest.as,
        Component = _rest$as === void 0 ? 'div' : _rest$as,
        passthroughProps = _objectWithoutPropertiesLoose(rest, ["as"]);

    return React.createElement(NestingContext.Provider, {
      value: nesting
    }, React.createElement(Component, Object.assign({}, passthroughProps, {
      ref: container
    }), children));
  }

  function Transition(props) {
    var _match;

    var show = props.show,
        _props$appear = props.appear,
        appear = _props$appear === void 0 ? false : _props$appear,
        rest = _objectWithoutPropertiesLoose(props, ["show", "appear"]);

    if (![true, false].includes(show)) {
      throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.');
    }

    var _React$useState2 = React.useState(show ? TreeStates.Visible : TreeStates.Hidden),
        state = _React$useState2[0],
        setState = _React$useState2[1];

    var nestingBag = useNesting(function () {
      setState(TreeStates.Hidden);
    });
    var initial = useIsInitialRender();
    var transitionBag = React.useMemo(function () {
      return {
        show: show,
        appear: appear || !initial
      };
    }, [show, appear, initial]);
    React.useEffect(function () {
      if (show) {
        setState(TreeStates.Visible);
      } else if (nestingBag.children.current.length <= 0) {
        setState(TreeStates.Hidden);
      }
    }, [show, nestingBag]);
    return React.createElement(NestingContext.Provider, {
      value: nestingBag
    }, React.createElement(TransitionContext.Provider, {
      value: transitionBag
    }, match(state, (_match = {}, _match[TreeStates.Visible] = function () {
      return React.createElement(TransitionChild, Object.assign({}, rest));
    }, _match[TreeStates.Hidden] = null, _match))));
  }
  Transition.Child = TransitionChild;

  function render(props, bag, tag) {
    var _props$as = props.as,
        Component = _props$as === void 0 ? tag : _props$as,
        children = props.children,
        passThroughProps = _objectWithoutPropertiesLoose(props, ["as", "children"]);

    var resolvedChildren = typeof children === 'function' ? children(bag) : children;

    if (Component === React.Fragment) {
      if (Object.keys(passThroughProps).length > 0) {
        if (Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {
          var err = new Error('You should only render 1 child');
          if (Error.captureStackTrace) Error.captureStackTrace(err, render);
          throw err;
        }

        if (!React.isValidElement(resolvedChildren)) {
          var _err = new Error("You should render an element as a child. Did you forget the as=\"...\" prop?");

          if (Error.captureStackTrace) Error.captureStackTrace(_err, render);
          throw _err;
        }

        return React.cloneElement(resolvedChildren, // Filter out undefined values so that they don't override the existing values
        mergeEventFunctions(compact(passThroughProps), resolvedChildren.props, ['onClick']));
      }
    }

    return React.createElement(Component, passThroughProps, resolvedChildren);
  }
  /**
   * We can use this function for the following useCase:
   *
   * <Menu.Item> <button onClick={console.log} /> </Menu.Item>
   *
   * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual
   * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual
   * first child, that one should _also_ be called (but before this implementation, it was just
   * overriding the `onClick`). But it is only when we *render* that we have access to the existing
   * props of this component.
   *
   * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on
   * so that we can refactor this later (if needed).
   */

  function mergeEventFunctions(passThroughProps, existingProps, functionsToMerge) {
    var clone = Object.assign({}, passThroughProps);

    var _loop = function _loop() {
      var func = _step.value;

      if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {
        var _Object$assign;

        Object.assign(clone, (_Object$assign = {}, _Object$assign[func] = function (event) {
          // Props we control
          if (!event.defaultPrevented) passThroughProps[func](event); // Existing props on the component

          if (!event.defaultPrevented) existingProps[func](event);
        }, _Object$assign));
      }
    };

    for (var _iterator = _createForOfIteratorHelperLoose(functionsToMerge), _step; !(_step = _iterator()).done;) {
      _loop();
    }

    return clone;
  }
  /**
   * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to
   * wrap it in a forwardRef so that we _can_ passthrough the ref
   */


  function forwardRefWithAs(component) {
    return React.forwardRef(component);
  }

  function compact(object) {
    var clone = Object.assign({}, object);

    for (var key in clone) {
      if (clone[key] === undefined) delete clone[key];
    }

    return clone;
  }

  function useDisposables() {
    // Using useState instead of useRef so that we can use the initializer function.
    var _React$useState = React.useState(disposables),
        d = _React$useState[0];

    React.useEffect(function () {
      return function () {
        return d.dispose();
      };
    }, [d]);
    return d;
  }

  function useSyncRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }

    return React.useCallback(function (value) {
      refs.forEach(function (ref) {
        if (ref === null) return;
        if (typeof ref === 'function') return ref(value);
        ref.current = value;
      });
    }, [refs]);
  }

  // TODO: This must already exist somewhere, right? ðŸ¤”
  // Ref: https://www.w3.org/TR/uievents-key/#named-key-attribute-values
  var Keys;

  (function (Keys) {
    Keys["Space"] = " ";
    Keys["Enter"] = "Enter";
    Keys["Escape"] = "Escape";
    Keys["Backspace"] = "Backspace";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["Home"] = "Home";
    Keys["End"] = "End";
    Keys["PageUp"] = "PageUp";
    Keys["PageDown"] = "PageDown";
    Keys["Tab"] = "Tab";
  })(Keys || (Keys = {}));

  var _reducers;
  var MenuStates;

  (function (MenuStates) {
    MenuStates[MenuStates["Open"] = 0] = "Open";
    MenuStates[MenuStates["Closed"] = 1] = "Closed";
  })(MenuStates || (MenuStates = {}));

  var ActionTypes;

  (function (ActionTypes) {
    ActionTypes[ActionTypes["OpenMenu"] = 0] = "OpenMenu";
    ActionTypes[ActionTypes["CloseMenu"] = 1] = "CloseMenu";
    ActionTypes[ActionTypes["GoToItem"] = 2] = "GoToItem";
    ActionTypes[ActionTypes["Search"] = 3] = "Search";
    ActionTypes[ActionTypes["ClearSearch"] = 4] = "ClearSearch";
    ActionTypes[ActionTypes["RegisterItem"] = 5] = "RegisterItem";
    ActionTypes[ActionTypes["UnregisterItem"] = 6] = "UnregisterItem";
  })(ActionTypes || (ActionTypes = {}));

  var Focus;

  (function (Focus) {
    Focus[Focus["FirstItem"] = 0] = "FirstItem";
    Focus[Focus["PreviousItem"] = 1] = "PreviousItem";
    Focus[Focus["NextItem"] = 2] = "NextItem";
    Focus[Focus["LastItem"] = 3] = "LastItem";
    Focus[Focus["SpecificItem"] = 4] = "SpecificItem";
    Focus[Focus["Nothing"] = 5] = "Nothing";
  })(Focus || (Focus = {}));

  function calculateActiveItemIndex(state, focus, id) {
    var _state$activeItemInde, _match;

    if (state.items.length <= 0) return null;
    var items = state.items;
    var activeItemIndex = (_state$activeItemInde = state.activeItemIndex) !== null && _state$activeItemInde !== void 0 ? _state$activeItemInde : -1;
    var nextActiveIndex = match(focus, (_match = {}, _match[Focus.FirstItem] = function () {
      return items.findIndex(function (item) {
        return !item.dataRef.current.disabled;
      });
    }, _match[Focus.PreviousItem] = function () {
      var idx = items.slice().reverse().findIndex(function (item, idx, all) {
        if (activeItemIndex !== -1 && all.length - idx - 1 >= activeItemIndex) return false;
        return !item.dataRef.current.disabled;
      });
      if (idx === -1) return idx;
      return items.length - 1 - idx;
    }, _match[Focus.NextItem] = function () {
      return items.findIndex(function (item, idx) {
        if (idx <= activeItemIndex) return false;
        return !item.dataRef.current.disabled;
      });
    }, _match[Focus.LastItem] = function () {
      var idx = items.slice().reverse().findIndex(function (item) {
        return !item.dataRef.current.disabled;
      });
      if (idx === -1) return idx;
      return items.length - 1 - idx;
    }, _match[Focus.SpecificItem] = function () {
      return items.findIndex(function (item) {
        return item.id === id;
      });
    }, _match[Focus.Nothing] = function () {
      return null;
    }, _match));
    if (nextActiveIndex === -1) return state.activeItemIndex;
    return nextActiveIndex;
  }

  var reducers = (_reducers = {}, _reducers[ActionTypes.CloseMenu] = function (state) {
    return _extends({}, state, {
      menuState: MenuStates.Closed
    });
  }, _reducers[ActionTypes.OpenMenu] = function (state) {
    return _extends({}, state, {
      menuState: MenuStates.Open
    });
  }, _reducers[ActionTypes.GoToItem] = function (state, action) {
    var activeItemIndex = calculateActiveItemIndex(state, action.focus, action.id);

    if (state.searchQuery === '' && state.activeItemIndex === activeItemIndex) {
      return state;
    }

    return _extends({}, state, {
      searchQuery: '',
      activeItemIndex: activeItemIndex
    });
  }, _reducers[ActionTypes.Search] = function (state, action) {
    var searchQuery = state.searchQuery + action.value;
    var match = state.items.findIndex(function (item) {
      var _item$dataRef$current;

      return ((_item$dataRef$current = item.dataRef.current.textValue) === null || _item$dataRef$current === void 0 ? void 0 : _item$dataRef$current.startsWith(searchQuery)) && !item.dataRef.current.disabled;
    });

    if (match === -1 || match === state.activeItemIndex) {
      return _extends({}, state, {
        searchQuery: searchQuery
      });
    }

    return _extends({}, state, {
      searchQuery: searchQuery,
      activeItemIndex: match
    });
  }, _reducers[ActionTypes.ClearSearch] = function (state) {
    return _extends({}, state, {
      searchQuery: ''
    });
  }, _reducers[ActionTypes.RegisterItem] = function (state, action) {
    return _extends({}, state, {
      items: [].concat(state.items, [{
        id: action.id,
        dataRef: action.dataRef
      }])
    });
  }, _reducers[ActionTypes.UnregisterItem] = function (state, action) {
    var nextItems = state.items.slice();
    var currentActiveItem = state.activeItemIndex !== null ? nextItems[state.activeItemIndex] : null;
    var idx = nextItems.findIndex(function (a) {
      return a.id === action.id;
    });
    if (idx !== -1) nextItems.splice(idx, 1);
    return _extends({}, state, {
      items: nextItems,
      activeItemIndex: function () {
        if (idx === state.activeItemIndex) return null;
        if (currentActiveItem === null) return null; // If we removed the item before the actual active index, then it would be out of sync. To
        // fix this, we will find the correct (new) index position.

        return nextItems.indexOf(currentActiveItem);
      }()
    });
  }, _reducers);
  var MenuContext = /*#__PURE__*/React.createContext(null);

  function useMenuContext(component) {
    var context = React.useContext(MenuContext);

    if (context === null) {
      var err = new Error("<" + component + " /> is missing a parent <" + Menu.name + " /> component.");

      if (Error.captureStackTrace) {
        Error.captureStackTrace(err, useMenuContext);
      }

      throw err;
    }

    return context;
  }

  function stateReducer(state, action) {
    return match(action.type, reducers, state, action);
  } // ---


  var DEFAULT_MENU_TAG = React.Fragment;
  function Menu(props) {
    var d = useDisposables();
    var reducerBag = React.useReducer(stateReducer, {
      menuState: MenuStates.Closed,
      buttonRef: React.createRef(),
      itemsRef: React.createRef(),
      items: [],
      searchQuery: '',
      activeItemIndex: null
    });
    var _reducerBag$ = reducerBag[0],
        menuState = _reducerBag$.menuState,
        itemsRef = _reducerBag$.itemsRef,
        buttonRef = _reducerBag$.buttonRef,
        dispatch = reducerBag[1];
    React.useEffect(function () {
      function handler(event) {
        var _buttonRef$current, _itemsRef$current;

        if (menuState !== MenuStates.Open) return;
        if ((_buttonRef$current = buttonRef.current) === null || _buttonRef$current === void 0 ? void 0 : _buttonRef$current.contains(event.target)) return;

        if (!((_itemsRef$current = itemsRef.current) === null || _itemsRef$current === void 0 ? void 0 : _itemsRef$current.contains(event.target))) {
          dispatch({
            type: ActionTypes.CloseMenu
          });
        }

        if (!event.defaultPrevented) d.nextFrame(function () {
          var _buttonRef$current2;

          return (_buttonRef$current2 = buttonRef.current) === null || _buttonRef$current2 === void 0 ? void 0 : _buttonRef$current2.focus();
        });
      }

      window.addEventListener('click', handler);
      return function () {
        return window.removeEventListener('click', handler);
      };
    }, [menuState, itemsRef, buttonRef, d, dispatch]);
    var propsBag = React.useMemo(function () {
      return {
        open: menuState === MenuStates.Open
      };
    }, [menuState]);
    return React.createElement(MenuContext.Provider, {
      value: reducerBag
    }, render(props, propsBag, DEFAULT_MENU_TAG));
  }
  var DEFAULT_BUTTON_TAG = 'button';
  var Button = /*#__PURE__*/forwardRefWithAs(function Button(props, ref) {
    var _state$itemsRef$curre5;

    var _useMenuContext = useMenuContext([Menu.name, Button.name].join('.')),
        state = _useMenuContext[0],
        dispatch = _useMenuContext[1];

    var buttonRef = useSyncRefs(state.buttonRef, ref);

    var _React$useState = React.useState(false),
        focused = _React$useState[0],
        setFocused = _React$useState[1];

    var id = "headlessui-menu-button-" + useId();
    var d = useDisposables();
    var handleKeyDown = React.useCallback(function (event) {
      switch (event.key) {
        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-13
        case Keys.Space:
        case Keys.Enter:
        case Keys.ArrowDown:
          event.preventDefault();
          dispatch({
            type: ActionTypes.OpenMenu
          });
          d.nextFrame(function () {
            var _state$itemsRef$curre;

            (_state$itemsRef$curre = state.itemsRef.current) === null || _state$itemsRef$curre === void 0 ? void 0 : _state$itemsRef$curre.focus();
            dispatch({
              type: ActionTypes.GoToItem,
              focus: Focus.FirstItem
            });
          });
          break;

        case Keys.ArrowUp:
          event.preventDefault();
          dispatch({
            type: ActionTypes.OpenMenu
          });
          d.nextFrame(function () {
            var _state$itemsRef$curre2;

            (_state$itemsRef$curre2 = state.itemsRef.current) === null || _state$itemsRef$curre2 === void 0 ? void 0 : _state$itemsRef$curre2.focus();
            dispatch({
              type: ActionTypes.GoToItem,
              focus: Focus.LastItem
            });
          });
          break;
      }
    }, [dispatch, state, d]);
    var handlePointerUp = React.useCallback(function (event) {
      if (state.menuState === MenuStates.Open) {
        dispatch({
          type: ActionTypes.CloseMenu
        });
        d.nextFrame(function () {
          var _state$buttonRef$curr;

          return (_state$buttonRef$curr = state.buttonRef.current) === null || _state$buttonRef$curr === void 0 ? void 0 : _state$buttonRef$curr.focus();
        });
      } else {
        event.preventDefault();
        dispatch({
          type: ActionTypes.OpenMenu
        });
        d.nextFrame(function () {
          var _state$itemsRef$curre3;

          return (_state$itemsRef$curre3 = state.itemsRef.current) === null || _state$itemsRef$curre3 === void 0 ? void 0 : _state$itemsRef$curre3.focus();
        });
      }
    }, [dispatch, d, state]);
    var handleFocus = React.useCallback(function () {
      var _state$itemsRef$curre4;

      if (state.menuState === MenuStates.Open) (_state$itemsRef$curre4 = state.itemsRef.current) === null || _state$itemsRef$curre4 === void 0 ? void 0 : _state$itemsRef$curre4.focus();
      setFocused(true);
    }, [state, setFocused]);
    var handleBlur = React.useCallback(function () {
      return setFocused(false);
    }, [setFocused]);
    var propsBag = React.useMemo(function () {
      return {
        open: state.menuState === MenuStates.Open,
        focused: focused
      };
    }, [state, focused]);
    var passthroughProps = props;
    var propsWeControl = {
      ref: buttonRef,
      id: id,
      type: 'button',
      'aria-haspopup': true,
      'aria-controls': (_state$itemsRef$curre5 = state.itemsRef.current) === null || _state$itemsRef$curre5 === void 0 ? void 0 : _state$itemsRef$curre5.id,
      'aria-expanded': state.menuState === MenuStates.Open ? true : undefined,
      onKeyDown: handleKeyDown,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onPointerUp: handlePointerUp
    };
    return render(_extends({}, passthroughProps, propsWeControl), propsBag, DEFAULT_BUTTON_TAG);
  });
  var DEFAULT_ITEMS_TAG = 'div';
  var Items = /*#__PURE__*/forwardRefWithAs(function Items(props, ref) {
    var _state$items$state$ac, _state$buttonRef$curr4;

    var _props$static = props["static"],
        isStatic = _props$static === void 0 ? false : _props$static,
        passthroughProps = _objectWithoutPropertiesLoose(props, ["static"]);

    var _useMenuContext2 = useMenuContext([Menu.name, Items.name].join('.')),
        state = _useMenuContext2[0],
        dispatch = _useMenuContext2[1];

    var itemsRef = useSyncRefs(state.itemsRef, ref);
    var id = "headlessui-menu-items-" + useId();
    var searchDisposables = useDisposables();
    var handleKeyDown = React.useCallback(function (event) {
      searchDisposables.dispose();

      switch (event.key) {
        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-12
        // @ts-expect-error Fallthrough is expected here
        case Keys.Space:
          if (state.searchQuery !== '') {
            event.preventDefault();
            return dispatch({
              type: ActionTypes.Search,
              value: event.key
            });
          }

        // When in type ahead mode, fallthrough

        case Keys.Enter:
          event.preventDefault();
          dispatch({
            type: ActionTypes.CloseMenu
          });

          if (state.activeItemIndex !== null) {
            var _document$getElementB;

            var _id = state.items[state.activeItemIndex].id;
            (_document$getElementB = document.getElementById(_id)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.click();
          }

          disposables().nextFrame(function () {
            var _state$buttonRef$curr2;

            return (_state$buttonRef$curr2 = state.buttonRef.current) === null || _state$buttonRef$curr2 === void 0 ? void 0 : _state$buttonRef$curr2.focus();
          });
          break;

        case Keys.ArrowDown:
          event.preventDefault();
          return dispatch({
            type: ActionTypes.GoToItem,
            focus: Focus.NextItem
          });

        case Keys.ArrowUp:
          event.preventDefault();
          return dispatch({
            type: ActionTypes.GoToItem,
            focus: Focus.PreviousItem
          });

        case Keys.Home:
        case Keys.PageUp:
          event.preventDefault();
          return dispatch({
            type: ActionTypes.GoToItem,
            focus: Focus.FirstItem
          });

        case Keys.End:
        case Keys.PageDown:
          event.preventDefault();
          return dispatch({
            type: ActionTypes.GoToItem,
            focus: Focus.LastItem
          });

        case Keys.Escape:
          event.preventDefault();
          dispatch({
            type: ActionTypes.CloseMenu
          });
          disposables().nextFrame(function () {
            var _state$buttonRef$curr3;

            return (_state$buttonRef$curr3 = state.buttonRef.current) === null || _state$buttonRef$curr3 === void 0 ? void 0 : _state$buttonRef$curr3.focus();
          });
          break;

        case Keys.Tab:
          return event.preventDefault();

        default:
          if (event.key.length === 1) {
            dispatch({
              type: ActionTypes.Search,
              value: event.key
            });
            searchDisposables.setTimeout(function () {
              return dispatch({
                type: ActionTypes.ClearSearch
              });
            }, 350);
          }

          break;
      }
    }, [dispatch, searchDisposables, state]);
    var propsBag = React.useMemo(function () {
      return {
        open: state.menuState === MenuStates.Open
      };
    }, [state]);
    var propsWeControl = {
      'aria-activedescendant': state.activeItemIndex === null ? undefined : (_state$items$state$ac = state.items[state.activeItemIndex]) === null || _state$items$state$ac === void 0 ? void 0 : _state$items$state$ac.id,
      'aria-labelledby': (_state$buttonRef$curr4 = state.buttonRef.current) === null || _state$buttonRef$curr4 === void 0 ? void 0 : _state$buttonRef$curr4.id,
      id: id,
      onKeyDown: handleKeyDown,
      role: 'menu',
      tabIndex: 0
    };
    if (!isStatic && state.menuState === MenuStates.Closed) return null;
    return render(_extends({}, passthroughProps, propsWeControl, {
      ref: itemsRef
    }), propsBag, DEFAULT_ITEMS_TAG);
  });
  var DEFAULT_ITEM_TAG = React.Fragment;

  function Item(props) {
    var _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        className = props.className,
        onClick = props.onClick,
        passthroughProps = _objectWithoutPropertiesLoose(props, ["disabled", "className", "onClick"]);

    var _useMenuContext3 = useMenuContext([Menu.name, Item.name].join('.')),
        state = _useMenuContext3[0],
        dispatch = _useMenuContext3[1];

    var d = useDisposables();
    var id = "headlessui-menu-item-" + useId();
    var active = state.activeItemIndex !== null ? state.items[state.activeItemIndex].id === id : false;
    var bag = React.useRef({
      disabled: disabled
    });
    useIsoMorphicEffect(function () {
      bag.current.disabled = disabled;
    }, [bag, disabled]);
    useIsoMorphicEffect(function () {
      var _document$getElementB2, _document$getElementB3;

      bag.current.textValue = (_document$getElementB2 = document.getElementById(id)) === null || _document$getElementB2 === void 0 ? void 0 : (_document$getElementB3 = _document$getElementB2.textContent) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.toLowerCase();
    }, [bag, id]);
    useIsoMorphicEffect(function () {
      dispatch({
        type: ActionTypes.RegisterItem,
        id: id,
        dataRef: bag
      });
      return function () {
        return dispatch({
          type: ActionTypes.UnregisterItem,
          id: id
        });
      };
    }, [bag, id]);
    var handleClick = React.useCallback(function (event) {
      if (disabled) return event.preventDefault();
      dispatch({
        type: ActionTypes.CloseMenu
      });
      d.nextFrame(function () {
        var _state$buttonRef$curr5;

        return (_state$buttonRef$curr5 = state.buttonRef.current) === null || _state$buttonRef$curr5 === void 0 ? void 0 : _state$buttonRef$curr5.focus();
      });
      if (onClick) return onClick(event);
    }, [d, dispatch, state.buttonRef, disabled, onClick]);
    var handleFocus = React.useCallback(function () {
      if (disabled) return dispatch({
        type: ActionTypes.GoToItem,
        focus: Focus.Nothing
      });
      dispatch({
        type: ActionTypes.GoToItem,
        focus: Focus.SpecificItem,
        id: id
      });
    }, [disabled, id, dispatch]);
    var handlePointerMove = React.useCallback(function () {
      if (disabled) return;
      if (active) return;
      dispatch({
        type: ActionTypes.GoToItem,
        focus: Focus.SpecificItem,
        id: id
      });
    }, [disabled, active, id, dispatch]);
    var handlePointerLeave = React.useCallback(function () {
      if (disabled) return;
      if (!active) return;
      dispatch({
        type: ActionTypes.GoToItem,
        focus: Focus.Nothing
      });
    }, [disabled, active, dispatch]);
    var propsBag = React.useMemo(function () {
      return {
        active: active,
        disabled: disabled
      };
    }, [active, disabled]);
    var propsWeControl = {
      id: id,
      role: 'menuitem',
      tabIndex: -1,
      className: resolvePropValue(className, propsBag),
      'aria-disabled': disabled === true ? true : undefined,
      onClick: handleClick,
      onFocus: handleFocus,
      onPointerMove: handlePointerMove,
      onPointerLeave: handlePointerLeave
    };
    return render(_extends({}, passthroughProps, propsWeControl), propsBag, DEFAULT_ITEM_TAG);
  }

  function resolvePropValue(property, bag) {
    if (property === undefined) return undefined;
    if (typeof property === 'function') return property(bag);
    return property;
  } // ---


  Menu.Button = Button;
  Menu.Items = Items;
  Menu.Item = Item;

  function useComputed(cb, dependencies) {
    var _React$useState = React.useState(cb),
        value = _React$useState[0],
        setValue = _React$useState[1];

    var cbRef = React.useRef(cb);
    useIsoMorphicEffect(function () {
      cbRef.current = cb;
    }, [cb]);
    useIsoMorphicEffect(function () {
      return setValue(cbRef.current);
    }, [cbRef, setValue].concat(dependencies));
    return value;
  }

  var _reducers$1;
  var ListboxStates;

  (function (ListboxStates) {
    ListboxStates[ListboxStates["Open"] = 0] = "Open";
    ListboxStates[ListboxStates["Closed"] = 1] = "Closed";
  })(ListboxStates || (ListboxStates = {}));

  var ActionTypes$1;

  (function (ActionTypes) {
    ActionTypes[ActionTypes["OpenListbox"] = 0] = "OpenListbox";
    ActionTypes[ActionTypes["CloseListbox"] = 1] = "CloseListbox";
    ActionTypes[ActionTypes["GoToOption"] = 2] = "GoToOption";
    ActionTypes[ActionTypes["Search"] = 3] = "Search";
    ActionTypes[ActionTypes["ClearSearch"] = 4] = "ClearSearch";
    ActionTypes[ActionTypes["RegisterOption"] = 5] = "RegisterOption";
    ActionTypes[ActionTypes["UnregisterOption"] = 6] = "UnregisterOption";
  })(ActionTypes$1 || (ActionTypes$1 = {}));

  var Focus$1;

  (function (Focus) {
    Focus[Focus["First"] = 0] = "First";
    Focus[Focus["Previous"] = 1] = "Previous";
    Focus[Focus["Next"] = 2] = "Next";
    Focus[Focus["Last"] = 3] = "Last";
    Focus[Focus["Specific"] = 4] = "Specific";
    Focus[Focus["Nothing"] = 5] = "Nothing";
  })(Focus$1 || (Focus$1 = {}));

  function calculateActiveOptionIndex(state, focus, id) {
    var _state$activeOptionIn, _match;

    if (state.options.length <= 0) return null;
    var options = state.options;
    var activeOptionIndex = (_state$activeOptionIn = state.activeOptionIndex) !== null && _state$activeOptionIn !== void 0 ? _state$activeOptionIn : -1;
    var nextActiveIndex = match(focus, (_match = {}, _match[Focus$1.First] = function () {
      return options.findIndex(function (option) {
        return !option.dataRef.current.disabled;
      });
    }, _match[Focus$1.Previous] = function () {
      var idx = options.slice().reverse().findIndex(function (option, idx, all) {
        if (activeOptionIndex !== -1 && all.length - idx - 1 >= activeOptionIndex) return false;
        return !option.dataRef.current.disabled;
      });
      if (idx === -1) return idx;
      return options.length - 1 - idx;
    }, _match[Focus$1.Next] = function () {
      return options.findIndex(function (option, idx) {
        if (idx <= activeOptionIndex) return false;
        return !option.dataRef.current.disabled;
      });
    }, _match[Focus$1.Last] = function () {
      var idx = options.slice().reverse().findIndex(function (option) {
        return !option.dataRef.current.disabled;
      });
      if (idx === -1) return idx;
      return options.length - 1 - idx;
    }, _match[Focus$1.Specific] = function () {
      return options.findIndex(function (option) {
        return option.id === id;
      });
    }, _match[Focus$1.Nothing] = function () {
      return null;
    }, _match));
    if (nextActiveIndex === -1) return state.activeOptionIndex;
    return nextActiveIndex;
  }

  var reducers$1 = (_reducers$1 = {}, _reducers$1[ActionTypes$1.CloseListbox] = function (state) {
    return _extends({}, state, {
      listboxState: ListboxStates.Closed
    });
  }, _reducers$1[ActionTypes$1.OpenListbox] = function (state) {
    return _extends({}, state, {
      listboxState: ListboxStates.Open
    });
  }, _reducers$1[ActionTypes$1.GoToOption] = function (state, action) {
    var activeOptionIndex = calculateActiveOptionIndex(state, action.focus, action.id);

    if (state.searchQuery === '' && state.activeOptionIndex === activeOptionIndex) {
      return state;
    }

    return _extends({}, state, {
      searchQuery: '',
      activeOptionIndex: activeOptionIndex
    });
  }, _reducers$1[ActionTypes$1.Search] = function (state, action) {
    var searchQuery = state.searchQuery + action.value;
    var match = state.options.findIndex(function (option) {
      var _option$dataRef$curre;

      return !option.dataRef.current.disabled && ((_option$dataRef$curre = option.dataRef.current.textValue) === null || _option$dataRef$curre === void 0 ? void 0 : _option$dataRef$curre.startsWith(searchQuery));
    });

    if (match === -1 || match === state.activeOptionIndex) {
      return _extends({}, state, {
        searchQuery: searchQuery
      });
    }

    return _extends({}, state, {
      searchQuery: searchQuery,
      activeOptionIndex: match
    });
  }, _reducers$1[ActionTypes$1.ClearSearch] = function (state) {
    return _extends({}, state, {
      searchQuery: ''
    });
  }, _reducers$1[ActionTypes$1.RegisterOption] = function (state, action) {
    return _extends({}, state, {
      options: [].concat(state.options, [{
        id: action.id,
        dataRef: action.dataRef
      }])
    });
  }, _reducers$1[ActionTypes$1.UnregisterOption] = function (state, action) {
    var nextOptions = state.options.slice();
    var currentActiveOption = state.activeOptionIndex !== null ? nextOptions[state.activeOptionIndex] : null;
    var idx = nextOptions.findIndex(function (a) {
      return a.id === action.id;
    });
    if (idx !== -1) nextOptions.splice(idx, 1);
    return _extends({}, state, {
      options: nextOptions,
      activeOptionIndex: function () {
        if (idx === state.activeOptionIndex) return null;
        if (currentActiveOption === null) return null; // If we removed the option before the actual active index, then it would be out of sync. To
        // fix this, we will find the correct (new) index position.

        return nextOptions.indexOf(currentActiveOption);
      }()
    });
  }, _reducers$1);
  var ListboxContext = /*#__PURE__*/React.createContext(null);

  function stateReducer$1(state, action) {
    return match(action.type, reducers$1, state, action);
  }

  function useListboxContext(component) {
    var context = React.useContext(ListboxContext);

    if (context === null) {
      var err = new Error("<" + component + " /> is missing a parent <" + Listbox.name + " /> component.");
      if (Error.captureStackTrace) Error.captureStackTrace(err, useListboxContext);
      throw err;
    }

    return context;
  } // ---


  var DEFAULT_LISTBOX_TAG = React.Fragment;
  function Listbox(props) {
    var value = props.value,
        onChange = props.onChange,
        passThroughProps = _objectWithoutPropertiesLoose(props, ["value", "onChange"]);

    var d = useDisposables();
    var reducerBag = React.useReducer(stateReducer$1, {
      listboxState: ListboxStates.Closed,
      propsRef: {
        current: {
          value: value,
          onChange: onChange
        }
      },
      labelRef: React.createRef(),
      buttonRef: React.createRef(),
      optionsRef: React.createRef(),
      options: [],
      searchQuery: '',
      activeOptionIndex: null
    });
    var _reducerBag$ = reducerBag[0],
        listboxState = _reducerBag$.listboxState,
        propsRef = _reducerBag$.propsRef,
        optionsRef = _reducerBag$.optionsRef,
        buttonRef = _reducerBag$.buttonRef,
        dispatch = reducerBag[1];
    useIsoMorphicEffect(function () {
      propsRef.current.value = value;
    }, [value, propsRef]);
    useIsoMorphicEffect(function () {
      propsRef.current.onChange = onChange;
    }, [onChange, propsRef]);
    React.useEffect(function () {
      function handler(event) {
        var _buttonRef$current, _optionsRef$current;

        if (listboxState !== ListboxStates.Open) return;
        if ((_buttonRef$current = buttonRef.current) === null || _buttonRef$current === void 0 ? void 0 : _buttonRef$current.contains(event.target)) return;

        if (!((_optionsRef$current = optionsRef.current) === null || _optionsRef$current === void 0 ? void 0 : _optionsRef$current.contains(event.target))) {
          dispatch({
            type: ActionTypes$1.CloseListbox
          });
        }

        if (!event.defaultPrevented) d.nextFrame(function () {
          var _buttonRef$current2;

          return (_buttonRef$current2 = buttonRef.current) === null || _buttonRef$current2 === void 0 ? void 0 : _buttonRef$current2.focus();
        });
      }

      window.addEventListener('click', handler);
      return function () {
        return window.removeEventListener('click', handler);
      };
    }, [listboxState, optionsRef, buttonRef, d, dispatch]);
    var propsBag = React.useMemo(function () {
      return {
        open: listboxState === ListboxStates.Open
      };
    }, [listboxState]);
    return React.createElement(ListboxContext.Provider, {
      value: reducerBag
    }, render(passThroughProps, propsBag, DEFAULT_LISTBOX_TAG));
  }
  var DEFAULT_BUTTON_TAG$1 = 'button';
  var Button$1 = /*#__PURE__*/forwardRefWithAs(function Button(props, ref) {
    var _state$optionsRef$cur5;

    var _useListboxContext = useListboxContext([Listbox.name, Button.name].join('.')),
        state = _useListboxContext[0],
        dispatch = _useListboxContext[1];

    var buttonRef = useSyncRefs(state.buttonRef, ref);

    var _React$useState = React.useState(false),
        focused = _React$useState[0],
        setFocused = _React$useState[1];

    var id = "headlessui-listbox-button-" + useId();
    var d = useDisposables();
    var handleKeyDown = React.useCallback(function (event) {
      switch (event.key) {
        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-13
        case Keys.Space:
        case Keys.Enter:
        case Keys.ArrowDown:
          event.preventDefault();
          dispatch({
            type: ActionTypes$1.OpenListbox
          });
          d.nextFrame(function () {
            var _state$optionsRef$cur;

            (_state$optionsRef$cur = state.optionsRef.current) === null || _state$optionsRef$cur === void 0 ? void 0 : _state$optionsRef$cur.focus();
            if (!state.propsRef.current.value) dispatch({
              type: ActionTypes$1.GoToOption,
              focus: Focus$1.First
            });
          });
          break;

        case Keys.ArrowUp:
          event.preventDefault();
          dispatch({
            type: ActionTypes$1.OpenListbox
          });
          d.nextFrame(function () {
            var _state$optionsRef$cur2;

            (_state$optionsRef$cur2 = state.optionsRef.current) === null || _state$optionsRef$cur2 === void 0 ? void 0 : _state$optionsRef$cur2.focus();
            if (!state.propsRef.current.value) dispatch({
              type: ActionTypes$1.GoToOption,
              focus: Focus$1.Last
            });
          });
          break;
      }
    }, [dispatch, state, d]);
    var handlePointerUp = React.useCallback(function (event) {
      if (state.listboxState === ListboxStates.Open) {
        dispatch({
          type: ActionTypes$1.CloseListbox
        });
        d.nextFrame(function () {
          var _state$buttonRef$curr;

          return (_state$buttonRef$curr = state.buttonRef.current) === null || _state$buttonRef$curr === void 0 ? void 0 : _state$buttonRef$curr.focus();
        });
      } else {
        event.preventDefault();
        dispatch({
          type: ActionTypes$1.OpenListbox
        });
        d.nextFrame(function () {
          var _state$optionsRef$cur3;

          return (_state$optionsRef$cur3 = state.optionsRef.current) === null || _state$optionsRef$cur3 === void 0 ? void 0 : _state$optionsRef$cur3.focus();
        });
      }
    }, [dispatch, d, state]);
    var handleFocus = React.useCallback(function () {
      var _state$optionsRef$cur4;

      if (state.listboxState === ListboxStates.Open) return (_state$optionsRef$cur4 = state.optionsRef.current) === null || _state$optionsRef$cur4 === void 0 ? void 0 : _state$optionsRef$cur4.focus();
      setFocused(true);
    }, [state, setFocused]);
    var handleBlur = React.useCallback(function () {
      return setFocused(false);
    }, [setFocused]);
    var labelledby = useComputed(function () {
      if (!state.labelRef.current) return undefined;
      return [state.labelRef.current.id, id].join(' ');
    }, [state.labelRef.current, id]);
    var propsBag = React.useMemo(function () {
      return {
        open: state.listboxState === ListboxStates.Open,
        focused: focused
      };
    }, [state, focused]);
    var passthroughProps = props;
    var propsWeControl = {
      ref: buttonRef,
      id: id,
      type: 'button',
      'aria-haspopup': true,
      'aria-controls': (_state$optionsRef$cur5 = state.optionsRef.current) === null || _state$optionsRef$cur5 === void 0 ? void 0 : _state$optionsRef$cur5.id,
      'aria-expanded': state.listboxState === ListboxStates.Open ? true : undefined,
      'aria-labelledby': labelledby,
      onKeyDown: handleKeyDown,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onPointerUp: handlePointerUp
    };
    return render(_extends({}, passthroughProps, propsWeControl), propsBag, DEFAULT_BUTTON_TAG$1);
  });
  var DEFAULT_LABEL_TAG = 'label';

  function Label(props) {
    var _useListboxContext2 = useListboxContext([Listbox.name, Label.name].join('.')),
        state = _useListboxContext2[0];

    var id = "headlessui-listbox-label-" + useId();
    var handlePointerUp = React.useCallback(function () {
      var _state$buttonRef$curr2;

      return (_state$buttonRef$curr2 = state.buttonRef.current) === null || _state$buttonRef$curr2 === void 0 ? void 0 : _state$buttonRef$curr2.focus();
    }, [state.buttonRef]);
    var propsBag = React.useMemo(function () {
      return {
        open: state.listboxState === ListboxStates.Open
      };
    }, [state]);
    var propsWeControl = {
      ref: state.labelRef,
      id: id,
      onPointerUp: handlePointerUp
    };
    return render(_extends({}, props, propsWeControl), propsBag, DEFAULT_LABEL_TAG);
  }

  var DEFAULT_OPTIONS_TAG = 'ul';
  var Options = /*#__PURE__*/forwardRefWithAs(function Options(props, ref) {
    var _state$options$state$;

    var _props$static = props["static"],
        isStatic = _props$static === void 0 ? false : _props$static,
        passthroughProps = _objectWithoutPropertiesLoose(props, ["enter", "enterFrom", "enterTo", "leave", "leaveFrom", "leaveTo", "static"]);

    var _useListboxContext3 = useListboxContext([Listbox.name, Options.name].join('.')),
        state = _useListboxContext3[0],
        dispatch = _useListboxContext3[1];

    var optionsRef = useSyncRefs(state.optionsRef, ref);
    var id = "headlessui-listbox-options-" + useId();
    var d = useDisposables();
    var searchDisposables = useDisposables();
    var handleKeyDown = React.useCallback(function (event) {
      searchDisposables.dispose();

      switch (event.key) {
        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-12
        // @ts-expect-error Fallthrough is expected here
        case Keys.Space:
          if (state.searchQuery !== '') {
            event.preventDefault();
            return dispatch({
              type: ActionTypes$1.Search,
              value: event.key
            });
          }

        // When in type ahead mode, fallthrough

        case Keys.Enter:
          event.preventDefault();
          dispatch({
            type: ActionTypes$1.CloseListbox
          });

          if (state.activeOptionIndex !== null) {
            var dataRef = state.options[state.activeOptionIndex].dataRef;
            state.propsRef.current.onChange(dataRef.current.value);
          }

          disposables().nextFrame(function () {
            var _state$buttonRef$curr3;

            return (_state$buttonRef$curr3 = state.buttonRef.current) === null || _state$buttonRef$curr3 === void 0 ? void 0 : _state$buttonRef$curr3.focus();
          });
          break;

        case Keys.ArrowDown:
          event.preventDefault();
          return dispatch({
            type: ActionTypes$1.GoToOption,
            focus: Focus$1.Next
          });

        case Keys.ArrowUp:
          event.preventDefault();
          return dispatch({
            type: ActionTypes$1.GoToOption,
            focus: Focus$1.Previous
          });

        case Keys.Home:
        case Keys.PageUp:
          event.preventDefault();
          return dispatch({
            type: ActionTypes$1.GoToOption,
            focus: Focus$1.First
          });

        case Keys.End:
        case Keys.PageDown:
          event.preventDefault();
          return dispatch({
            type: ActionTypes$1.GoToOption,
            focus: Focus$1.Last
          });

        case Keys.Escape:
          event.preventDefault();
          dispatch({
            type: ActionTypes$1.CloseListbox
          });
          return d.nextFrame(function () {
            var _state$buttonRef$curr4;

            return (_state$buttonRef$curr4 = state.buttonRef.current) === null || _state$buttonRef$curr4 === void 0 ? void 0 : _state$buttonRef$curr4.focus();
          });

        case Keys.Tab:
          return event.preventDefault();

        default:
          if (event.key.length === 1) {
            dispatch({
              type: ActionTypes$1.Search,
              value: event.key
            });
            searchDisposables.setTimeout(function () {
              return dispatch({
                type: ActionTypes$1.ClearSearch
              });
            }, 350);
          }

          break;
      }
    }, [d, dispatch, searchDisposables, state]);
    var labelledby = useComputed(function () {
      var _state$labelRef$curre, _state$labelRef$curre2, _state$buttonRef$curr5;

      return (_state$labelRef$curre = (_state$labelRef$curre2 = state.labelRef.current) === null || _state$labelRef$curre2 === void 0 ? void 0 : _state$labelRef$curre2.id) !== null && _state$labelRef$curre !== void 0 ? _state$labelRef$curre : (_state$buttonRef$curr5 = state.buttonRef.current) === null || _state$buttonRef$curr5 === void 0 ? void 0 : _state$buttonRef$curr5.id;
    }, [state.labelRef.current, state.buttonRef.current]);
    var propsBag = React.useMemo(function () {
      return {
        open: state.listboxState === ListboxStates.Open
      };
    }, [state]);
    var propsWeControl = {
      'aria-activedescendant': state.activeOptionIndex === null ? undefined : (_state$options$state$ = state.options[state.activeOptionIndex]) === null || _state$options$state$ === void 0 ? void 0 : _state$options$state$.id,
      'aria-labelledby': labelledby,
      id: id,
      onKeyDown: handleKeyDown,
      role: 'listbox',
      tabIndex: 0
    };
    if (!isStatic && state.listboxState === ListboxStates.Closed) return null;
    return render(_extends({}, passthroughProps, propsWeControl, {
      ref: optionsRef
    }), propsBag, DEFAULT_OPTIONS_TAG);
  });
  var DEFAULT_OPTION_TAG = 'li';

  function Option(props) {
    var _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        value = props.value,
        className = props.className,
        passthroughProps = _objectWithoutPropertiesLoose(props, ["disabled", "value", "className"]);

    var _useListboxContext4 = useListboxContext([Listbox.name, Option.name].join('.')),
        state = _useListboxContext4[0],
        dispatch = _useListboxContext4[1];

    var id = "headlessui-listbox-option-" + useId();
    var active = state.activeOptionIndex !== null ? state.options[state.activeOptionIndex].id === id : false;
    var selected = state.propsRef.current.value === value;
    var bag = React.useRef({
      disabled: disabled,
      value: value
    });
    useIsoMorphicEffect(function () {
      bag.current.disabled = disabled;
    }, [bag, disabled]);
    useIsoMorphicEffect(function () {
      bag.current.value = value;
    }, [bag, value]);
    useIsoMorphicEffect(function () {
      var _document$getElementB, _document$getElementB2;

      bag.current.textValue = (_document$getElementB = document.getElementById(id)) === null || _document$getElementB === void 0 ? void 0 : (_document$getElementB2 = _document$getElementB.textContent) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.toLowerCase();
    }, [bag, id]);
    var select = React.useCallback(function () {
      return state.propsRef.current.onChange(value);
    }, [state.propsRef, value]);
    useIsoMorphicEffect(function () {
      dispatch({
        type: ActionTypes$1.RegisterOption,
        id: id,
        dataRef: bag
      });
      return function () {
        return dispatch({
          type: ActionTypes$1.UnregisterOption,
          id: id
        });
      };
    }, [bag, id]);
    useIsoMorphicEffect(function () {
      var _document$getElementB3, _document$getElementB4;

      if (!selected) return;
      dispatch({
        type: ActionTypes$1.GoToOption,
        focus: Focus$1.Specific,
        id: id
      });
      (_document$getElementB3 = document.getElementById(id)) === null || _document$getElementB3 === void 0 ? void 0 : (_document$getElementB4 = _document$getElementB3.focus) === null || _document$getElementB4 === void 0 ? void 0 : _document$getElementB4.call(_document$getElementB3);
    }, []);
    useIsoMorphicEffect(function () {
      if (!active) return;
      var d = disposables();
      d.nextFrame(function () {
        var _document$getElementB5, _document$getElementB6;

        return (_document$getElementB5 = document.getElementById(id)) === null || _document$getElementB5 === void 0 ? void 0 : (_document$getElementB6 = _document$getElementB5.scrollIntoView) === null || _document$getElementB6 === void 0 ? void 0 : _document$getElementB6.call(_document$getElementB5, {
          block: 'nearest'
        });
      });
      return d.dispose;
    }, [active]);
    var handleClick = React.useCallback(function (event) {
      if (disabled) return event.preventDefault();
      select();
      dispatch({
        type: ActionTypes$1.CloseListbox
      });
      disposables().nextFrame(function () {
        var _state$buttonRef$curr6;

        return (_state$buttonRef$curr6 = state.buttonRef.current) === null || _state$buttonRef$curr6 === void 0 ? void 0 : _state$buttonRef$curr6.focus();
      });
    }, [dispatch, state.buttonRef, disabled, select]);
    var handleFocus = React.useCallback(function () {
      if (disabled) return dispatch({
        type: ActionTypes$1.GoToOption,
        focus: Focus$1.Nothing
      });
      dispatch({
        type: ActionTypes$1.GoToOption,
        focus: Focus$1.Specific,
        id: id
      });
    }, [disabled, id, dispatch]);
    var handlePointerMove = React.useCallback(function () {
      if (disabled) return;
      if (active) return;
      dispatch({
        type: ActionTypes$1.GoToOption,
        focus: Focus$1.Specific,
        id: id
      });
    }, [disabled, active, id, dispatch]);
    var handlePointerLeave = React.useCallback(function () {
      if (disabled) return;
      if (!active) return;
      dispatch({
        type: ActionTypes$1.GoToOption,
        focus: Focus$1.Nothing
      });
    }, [disabled, active, dispatch]);
    var propsBag = React.useMemo(function () {
      return {
        active: active,
        selected: selected,
        disabled: disabled
      };
    }, [active, selected, disabled]);
    var propsWeControl = {
      id: id,
      role: 'option',
      tabIndex: -1,
      className: resolvePropValue$1(className, propsBag),
      'aria-disabled': disabled === true ? true : undefined,
      'aria-selected': selected === true ? true : undefined,
      onClick: handleClick,
      onFocus: handleFocus,
      onPointerMove: handlePointerMove,
      onPointerLeave: handlePointerLeave
    };
    return render(_extends({}, passthroughProps, propsWeControl), propsBag, DEFAULT_OPTION_TAG);
  }

  function resolvePropValue$1(property, bag) {
    if (property === undefined) return undefined;
    if (typeof property === 'function') return property(bag);
    return property;
  } // ---


  Listbox.Button = Button$1;
  Listbox.Label = Label;
  Listbox.Options = Options;
  Listbox.Option = Option;

  var GroupContext = /*#__PURE__*/React.createContext(null);

  function useGroupContext(component) {
    var context = React.useContext(GroupContext);

    if (context === null) {
      var err = new Error("<" + component + " /> is missing a parent <Switch.Group /> component.");
      if (Error.captureStackTrace) Error.captureStackTrace(err, useGroupContext);
      throw err;
    }

    return context;
  } // ---


  var DEFAULT_GROUP_TAG = React.Fragment;

  function Group(props) {
    var _React$useState = React.useState(null),
        switchElement = _React$useState[0],
        setSwitchElement = _React$useState[1];

    var _React$useState2 = React.useState(null),
        labelElement = _React$useState2[0],
        setLabelElement = _React$useState2[1];

    var context = React.useMemo(function () {
      return {
        "switch": switchElement,
        label: labelElement,
        setSwitch: setSwitchElement,
        setLabel: setLabelElement
      };
    }, [switchElement, setSwitchElement, labelElement, setLabelElement]);
    return React.createElement(GroupContext.Provider, {
      value: context
    }, render(props, {}, DEFAULT_GROUP_TAG));
  } // ---


  var DEFAULT_SWITCH_TAG = 'button';
  function Switch(props) {
    var _groupContext$label;

    var checked = props.checked,
        onChange = props.onChange,
        className = props.className,
        passThroughProps = _objectWithoutPropertiesLoose(props, ["checked", "onChange", "className"]);

    var id = "headlessui-switch-" + useId();
    var groupContext = React.useContext(GroupContext);
    var toggle = React.useCallback(function () {
      return onChange(!checked);
    }, [onChange, checked]);
    var handleClick = React.useCallback(function (event) {
      event.preventDefault();
      toggle();
    }, [toggle]);
    var handleKeyUp = React.useCallback(function (event) {
      if (event.key === Keys.Space) {
        event.preventDefault();
        toggle();
      }
    }, [toggle]);
    var propsBag = React.useMemo(function () {
      return {
        checked: checked
      };
    }, [checked]);
    var propsWeControl = {
      id: id,
      ref: groupContext === null ? undefined : groupContext.setSwitch,
      role: 'switch',
      tabIndex: 0,
      className: resolvePropValue$2(className, propsBag),
      'aria-checked': checked,
      'aria-labelledby': groupContext === null || groupContext === void 0 ? void 0 : (_groupContext$label = groupContext.label) === null || _groupContext$label === void 0 ? void 0 : _groupContext$label.id,
      onClick: handleClick,
      onKeyUp: handleKeyUp
    };
    return render(_extends({}, passThroughProps, propsWeControl), propsBag, DEFAULT_SWITCH_TAG);
  }
  var DEFAULT_LABEL_TAG$1 = 'label';

  function Label$1(props) {
    var state = useGroupContext([Switch.name, Label$1.name].join('.'));
    var id = "headlessui-switch-label-" + useId();
    var handlePointerUp = React.useCallback(function () {
      if (!state["switch"]) return;
      state["switch"].click();
      state["switch"].focus();
    }, [state["switch"]]);
    var propsWeControl = {
      ref: state.setLabel,
      id: id,
      onPointerUp: handlePointerUp
    };
    return render(_extends({}, props, propsWeControl), {}, DEFAULT_LABEL_TAG$1);
  } // ---


  Switch.Group = Group;
  Switch.Label = Label$1; // ---

  function resolvePropValue$2(property, bag) {
    if (property === undefined) return undefined;
    if (typeof property === 'function') return property(bag);
    return property;
  }

  exports.Listbox = Listbox;
  exports.Menu = Menu;
  exports.Switch = Switch;
  exports.Transition = Transition;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=headlessui.umd.development.js.map
